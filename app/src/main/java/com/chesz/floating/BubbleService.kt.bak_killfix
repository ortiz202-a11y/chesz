package com.chesz.floating

import android.app.Service
import android.content.Intent
import android.graphics.PixelFormat
import android.graphics.Point
import android.os.Build
import android.os.IBinder
import android.view.*
import android.widget.FrameLayout
import android.widget.ImageView
import com.chesz.R
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.min

class BubbleService : Service() {

  private lateinit var wm: WindowManager

  // Bubble
  private lateinit var bubbleRoot: FrameLayout
  private lateinit var bubbleIcon: ImageView
  private lateinit var bubbleLp: WindowManager.LayoutParams

  // Kill area
  private lateinit var killRoot: FrameLayout
  private lateinit var killLp: WindowManager.LayoutParams
  private var killShown = false

  private var downRawX = 0f
  private var downRawY = 0f
  private var startX = 0
  private var startY = 0
  private var dragging = false

  override fun onBind(intent: Intent?): IBinder? = null

  override fun onCreate() {
    super.onCreate()
    wm = getSystemService(WINDOW_SERVICE) as WindowManager

    createBubble()
    createKillArea()
  }

  override fun onDestroy() {
    super.onDestroy()
    runCatching { wm.removeView(bubbleRoot) }
    runCatching { if (killShown) wm.removeView(killRoot) }
  }

  private fun overlayType(): Int {
    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
      WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
    else
      WindowManager.LayoutParams.TYPE_PHONE
  }

  private fun createBubble() {
    bubbleRoot = FrameLayout(this)
    bubbleIcon = ImageView(this).apply {
      // usa el icono que tu check sincroniza: drawable/bubble_icon.png
      setImageResource(R.drawable.bubble_icon)
      scaleType = ImageView.ScaleType.CENTER_CROP
      adjustViewBounds = true
    }

    val sizePx = dp(60)
    bubbleRoot.addView(
      bubbleIcon,
      FrameLayout.LayoutParams(sizePx, sizePx)
    )

    bubbleLp = WindowManager.LayoutParams(
      WindowManager.LayoutParams.WRAP_CONTENT,
      WindowManager.LayoutParams.WRAP_CONTENT,
      overlayType(),
      WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
      PixelFormat.TRANSLUCENT
    ).apply {
      gravity = Gravity.TOP or Gravity.START
      x = 0
      y = dp(120)
    }

    bubbleRoot.setOnTouchListener { _, e ->
      when (e.actionMasked) {
        MotionEvent.ACTION_DOWN -> {
          dragging = false
          downRawX = e.rawX
          downRawY = e.rawY
          startX = bubbleLp.x
          startY = bubbleLp.y
          true
        }

        MotionEvent.ACTION_MOVE -> {
            val dx = (e.rawX - downRawX).toInt()
            val dy = (e.rawY - downRawY).toInt()

            // Estándar: el kill SOLO aparece cuando ya es drag real (umbral)
            if (!dragging && (kotlin.math.abs(dx) + kotlin.math.abs(dy) > dp(6))) {
              dragging = true
              showKill(true)
            }

            bubbleLp.x = startX + dx
            bubbleLp.y = startY + dy
            wm.updateViewLayout(bubbleRoot, bubbleLp)

            // Hover solo durante drag
            if (dragging) {
              val over = isOverKillCenter(bubbleCenterX(), bubbleCenterY())
              setKillHover(over)
            }
            true
          }

        MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
            val shouldKill = dragging && isOverKillCenter(bubbleCenterX(), bubbleCenterY())
            showKill(false)

            if (shouldKill) {
              stopSelf()
            } else {
              // tap normal (no hace nada)
            }
            true
          }

        else -> false
      }
    }

    wm.addView(bubbleRoot, bubbleLp)
  }

  private fun createKillArea() {
    killRoot = FrameLayout(this).apply {
      // círculo rojo “succión”
      background = android.graphics.drawable.GradientDrawable().apply {
        shape = android.graphics.drawable.GradientDrawable.OVAL
        setColor(0xCCFF0000.toInt())
      }
      alpha = 0.0f
      scaleX = 1.0f
      scaleY = 1.0f
    }

    val xIcon = ImageView(this).apply {
      setImageResource(android.R.drawable.ic_delete)
      setColorFilter(0xFFFFFFFF.toInt())
      scaleType = ImageView.ScaleType.CENTER_INSIDE
    }

    val sizePx = dp(92)
    killRoot.addView(
      xIcon,
      FrameLayout.LayoutParams(dp(44), dp(44), Gravity.CENTER)
    )

    killLp = WindowManager.LayoutParams(
      sizePx,
      sizePx,
      overlayType(),
      WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
          or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
          or WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
      PixelFormat.TRANSLUCENT
    ).apply {
      gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL
      x = 0
      y = dp(28)
    }
  }

  private fun showKill(show: Boolean) {
    if (show) {
      if (!killShown) {
        wm.addView(killRoot, killLp)
        killShown = true
      }
      killRoot.animate().cancel()
      killRoot.animate().alpha(1f).setDuration(120).start()
    } else {
      if (!killShown) return
      killRoot.animate().cancel()
      killRoot.animate().alpha(0f).setDuration(120).withEndAction {
        runCatching { wm.removeView(killRoot) }
        killShown = false
      }.start()
    }
  }

  private fun setKillHover(hover: Boolean) {
      val target = if (hover) 1.85f else 1.0f
      killRoot.animate().cancel()
      killRoot.animate().scaleX(target).scaleY(target).setDuration(90).start()
    }

  private fun bubbleCenterX(): Float = bubbleLp.x + bubbleRoot.width / 2f
  private fun bubbleCenterY(): Float = bubbleLp.y + bubbleRoot.height / 2f

  private fun killCenterOnScreen(): Pair<Float, Float> {
    val display = wm.defaultDisplay
    val size = Point()
    display.getSize(size)
    val cx = size.x / 2f
    val cy = size.y - killLp.y - (killLp.height / 2f)
    return cx to cy
  }

  private fun isOverKillCenter(x: Float, y: Float): Boolean {
    val (cx, cy) = killCenterOnScreen()
    val r = (killLp.width / 2f) * 1.35f
    return hypot(x - cx, y - cy) <= r
  }

  


  
    private fun performKill() {
      // feedback fuerte tipo “succión”
      runCatching {
        killRoot.animate().cancel()
        killRoot.animate()
          .alpha(1f)
          .scaleX(2.2f)
          .scaleY(2.2f)
          .setDuration(140)
          .withEndAction {
            runCatching { wm.removeView(bubbleRoot) }
            runCatching { if (killShown) wm.removeView(killRoot) }
            killShown = false
            stopSelf()
          }
          .start()
      }.onFailure {
        // si algo falla, al menos intentamos cerrar
        runCatching { wm.removeView(bubbleRoot) }
        runCatching { if (killShown) wm.removeView(killRoot) }
        killShown = false
        stopSelf()
      }
    }

private fun dp(v: Int): Int {
    val d = resources.displayMetrics.density
    return (v * d).toInt()
  }
}
